#!/usr/bin/env ruby
require_relative "repository"

# exit if script called with no arguments
exit if ARGV.length == 0

# get command line arguments
cmd = ARGV[0]
args = ARGV[1..ARGV.length]


# creates an empty repository
if cmd == "init"
    # TODO: create new repo if none exits
    repo = Repository.new(".", true)
    exit
else
    repo = Repository.new()
end

# TODO: Do we need a branch command?

case cmd
# add speific files for tracking
# maybe starts with simple single file additions
# and then add ability to accept patterns
when "add"
    repo.add(args)
# remove specific files from tracking list
when "remove"
    repo.delete(args)
# check the status of the current repo compared to the head
when "status"
    repo.diffdir(repo.root)
# print out the current heads
when "heads"
    # TODO
# check the changes between two different revisions
when "diff"
    # TODO
# switch to a specific revision in history
when "checkout"
    rev = repo.changelog.top()
    rev = int(args[0]) unless args.empty?
    repo.checkout(rev)
# output a file version from a given revision
when "cat"
    # TODO
# commit staged changes -> create new revision
when "commit"
    repo.commit()
# print the changelog (i.e. revision history)
when "log"
    repo.changelog.top.times do |i|
        changes = repo.changelog.changeset(i)
        p1, p2 = repo.changelog.parents(i)
        print "#{i}: #{p1} #{p2} #{repo.changelog.node(i)}"
        print "manifest nodeid:", changes[0]
        print "user:", changes[1]
        print "changed files:"
        changes[3].each {|f| print "", f }
        print "description:"
        print changes[4]
    end
# merge two revisions
when "merge"
    other = Repository.new(args[0])
    repo.merge(other)
# pull the changes from another repository
when "pull"
    # TODO
# push the changes into another repository
when "push"
    # TODO
when "help"
    puts "TODO: Here is some help"
else
    puts "jsaw: '#{cmd}' is not a valid command. See 'jsaw help'."
end
